#SLogo API Review

Robert Steilberg | rhs16
Filip Mazurek | fjm7: reviewer

##Part 1

1. Our API design specifically involves the use of two different controllers: one for the front end, one for the back end. These controllers can thus communicate with each other and limit the dependencies between other classes in the front and back end. We intend to have a front-end controller that specifically manages the GUI and the actions on it that are triggered by the back end or triggered by the user. Meanwhile, we intend for our back-end controller to handle all of the specifics of interpreting commands and throwing exceptions back to the front end. Ideally, this will make it easier to understand how the front end interfaces with the back end, and how the front end or back end can be extended to add different functionality without having to heavily modify the core implementation of the program. Ultimately, we don't want the back end controller to be overly responsible for handling actions related to the GUI.
2. The classes in our internal and external APIs for the front end and back end specifically encapsulate functionality that is not meant to be directly exposed. For example, we have completely encapsulated the ways in which we parse and interpret user commands in the back end so that the front end need only feed a command into the back end and then receive an executable instruction from the back end. Our parser tree, which decomposes user commands into their individual subcomponents, is completely hidden from the front end of the application. However, we still need to make a design decision regarding how our application will handle compounding commands. Specifically, compound commands can either execute in succession that is showed to the user (i.e., forward-rotate-forward shows the user the actual steps as the turtle moves), or the command is interpreted as one single command, and the turtle is instantaneously placed in its new position on the window.
3. Exceptions will invariably occur when users enter Logo commands that are not correct in their syntax or for cannot be interpreted or executed for some other reason. These exceptions will be caught by the parser tree. After the parser tree has decomposed a submitted user command into subcomponents that cannot be reduced further, any leaves containing non-executable components will be recognized as errors within the overall command. The type of error will be determined (how this will be done has not been implemented yet) and that information will be passed back up through the back end controller to the GUI to alert the user that there is some exception or problem with the command that they submitted. Execution errors will be handled by the back end, and will likely be detected when the parser tree has successfully decomposed the command into valid subcommands, but there is some other error upon execution. However, we still need to decide if syntax-related errors are handled by the front end or the back end.
4. We think that the ways in which we intend for our front end to interface with our back end is good design, in the sense that it shouldn't be too difficult to achieve implementation-wise and that it will be easily extensible and minimize dependencies. Furthermore, we think that error checking will interface well with our method of command interpretation since it will be easy to detect errors in compound commands based out of the leaves of the parser tree. However, we don't quite have the implementation down for our back end and front end controllers; right now, our back end controllers is doing too much and doesn't really convey how we plan to control the actions of the back end and how they interact with the front end.


##Part 2

1. Use cases:
	* User issues command: The command is passed back through the controller into the back end. The back end builds a parser tree with the command to reduce it down into parseable subcomponents. The actions associated with each command are then calculated and passed back up to the front end GUI, where the actions are reflected on the display.
	* User issues "fs" command instead of "fd" command: The error will be checked for by ErrorChecker.java in the external back end API, which will use the internal back end API to check the parser tree for syntax issues. The syntax issue will be caught and an exception will be shown to the user.
	* User issues a command that moves the turtle out of the display view: The command is passed to the back end, executed, and then passed back up to the front end. The front end detects that the command is moving the turtle out of the display, halts execution, and shows an exception to the user.
	* User issues a command that references an undefined variable: When the command is interpreted by the back end, the command interpreter determines attempts to find a reference for the defined variable. If no reference is found, ErrorChecker.java is invoked, and an error is thrown back up to the user indicating that an undefined variable was referenced.
	* User issues a command that was previously interpreted: before each command is executed, the interpreter checks to see if the command is in the command history list. If it is, the back end controller (currently CommandParser.java, but subject to change) will not call for a new parser tree to be made, nor will it attempt to parse and interpret the command. Rather, the stored action of the previously called command will be returned back up to the front end GUI for execution.
2. Regular expressions will undoubtedly help me with my design of the back end since they are essential to parsing and interpreting user commands to be reflected in the GUI. Binding will also be important for ensuring that the GUI responds to each command that is parsed and issued by the back end.
3. I am most excited to learn how to parse and interpret input commands from a user, similar to designing a simple compiler for a simple language. I think that this will be a unique challenge for me, but I have always wanted to brush up on regular expressions, and I think this will be a good exercise for that.
4. I am most worried about interfacing the front end of the application with the back end. There seems to be a lot of information to pass between the front end and the back end, and I want to do so with minimal interaction and dependencies between the two sides of the application.